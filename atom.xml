<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-06T02:00:53.003Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 一步一步实现百度地图范围搜索</title>
    <link href="http://yoursite.com/2018/02/06/iOS-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E8%8C%83%E5%9B%B4%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/02/06/iOS-一步一步实现百度地图范围搜索/</id>
    <published>2018-02-06T02:00:46.000Z</published>
    <updated>2018-02-06T02:00:53.003Z</updated>
    
    <content type="html"><![CDATA[<p>#####实现百度地图显示范围内搜索关键词<br>效果图:<br><img src="http://upload-images.jianshu.io/upload_images/299599-b0d1d87d2a8c2cdc.gif?imageMogr2/auto-orient/strip" alt="未命名.gif"></p><p>######实现原理: 首先,要实现范围内搜索,就得借助地图搜索类方法,去百度地图SDK里查看,发现根据范围和搜索词的方法正是我们所需要的.</p><p><img src="http://upload-images.jianshu.io/upload_images/299599-2977562346ac8d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照_2016-06-16_下午3_27_11.png"></p><p>######接着去 BMKBoundSearchOption 里查看,发现要实现范围搜索只需要得到左下角和右上角的经纬度坐标点即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/299599-2c38bae8df72e1ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-06-16 下午3.34.45.png"></p><p>1.首先加载出百度地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    _mapView = [[BMKMapView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">    // 设置地图级别</span><br><span class="line">    [_mapView setZoomLevel:16];</span><br><span class="line">    _mapView.delegate= self;</span><br><span class="line">    _mapView.isSelectedAnnotationViewFront = YES;</span><br><span class="line">    [self.view addSubview:_mapView];</span><br></pre></td></tr></table></figure></p><pre><code>2.在地图加载成功后的方法里去得到左下角和右上角的坐标点的经纬度, 需要一个方法来实现屏幕坐标点转化成经纬度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    //加载完毕先调取一次检索</span><br><span class="line">    - (void)mapViewDidFinishLoading:(BMKMapView *)mapView</span><br><span class="line">    &#123;</span><br><span class="line">    leftBottomPoint = [_mapView convertPoint:CGPointMake(0,_mapView.frame.size.height) toCoordinateFromView:mapView];  // //西南角（左下角） 屏幕坐标转地理经纬度</span><br><span class="line">    rightBottomPoint = [_mapView convertPoint:CGPointMake(_mapView.frame.size.width,0) toCoordinateFromView:mapView];  //东北角（右上角）同上</span><br><span class="line">    //开始搜索</span><br><span class="line">    [self beginSearch];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>    3.得到俩个点的经纬度就可以开始发起搜索了。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        - (void)beginSearch&#123;</span><br><span class="line">            _poisearch = [[BMKPoiSearch alloc]init];</span><br><span class="line">                _poisearch.delegate = self;</span><br><span class="line">                                    </span><br><span class="line">                        BMKBoundSearchOption *boundSearchOption = [[BMKBoundSearchOption alloc]init];</span><br><span class="line">                            boundSearchOption.pageIndex = 0;</span><br><span class="line">                                boundSearchOption.pageCapacity = 20;</span><br><span class="line">                                    boundSearchOption.keyword = @&quot;烤鱼&quot;;</span><br><span class="line">                                        boundSearchOption.leftBottom =leftBottomPoint;</span><br><span class="line">                                            boundSearchOption.rightTop =rightBottomPoint;</span><br><span class="line">                                                                                            </span><br><span class="line">                                                    BOOL flag = [_poisearch poiSearchInbounds:boundSearchOption];</span><br><span class="line">                                                        if(flag)</span><br><span class="line">                                                            &#123;</span><br><span class="line">                                                                    NSLog(@&quot;范围内检索发送成功&quot;);</span><br><span class="line">                                                                        &#125;</span><br><span class="line">                                                                            else</span><br><span class="line">                                                                                &#123;</span><br><span class="line">                                                                                        NSLog(@&quot;范围内检索发送失败&quot;);</span><br><span class="line">                                                                                            &#125;</span><br><span class="line">                                                                                            &#125;</span><br></pre></td></tr></table></figure>                                                                                        4.在搜索结果的代理方法里将搜索到的结果展示出来。                                                                                        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">                                                                                            #pragma mark implement BMKSearchDelegate</span><br><span class="line">                                                                                            - (void)onGetPoiResult:(BMKPoiSearch *)searcher result:(BMKPoiResult*)result errorCode:(BMKSearchErrorCode)error</span><br><span class="line">                                                                                            &#123;</span><br><span class="line">                                                                                                if (error == BMK_SEARCH_NO_ERROR) &#123;</span><br><span class="line">                                                                                                        NSArray* array = [NSArray arrayWithArray:_mapView.annotations];</span><br><span class="line">                                                                                                                [_mapView removeAnnotations:array];</span><br><span class="line">                                                                                                                        array = [NSArray arrayWithArray:_mapView.overlays];</span><br><span class="line">                                                                                                                                [_mapView removeOverlays:array];</span><br><span class="line">                                                                                                                                        //在此处理正常结果</span><br><span class="line">                                                                                                                                                for (int i = 0; i &lt; result.poiInfoList.count; i++)</span><br><span class="line">                                                                                                                                                        &#123;</span><br><span class="line">                                                                                                                                                                    BMKPoiInfo* poi = [result.poiInfoList objectAtIndex:i];</span><br><span class="line">                                                                                                                                                                                [self addAnimatedAnnotationWithName:poi.name withAddress:poi.pt];</span><br><span class="line">                                                                                                                                                                                        &#125;</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                        </span><br><span class="line">                                                                                                                                                                                                    &#125; else if (error == BMK_SEARCH_AMBIGUOUS_ROURE_ADDR)&#123;</span><br><span class="line">                                                                                                                                                                                                            NSLog(@&quot;起始点有歧义&quot;);</span><br><span class="line">                                                                                                                                                                                                                &#125; else &#123;</span><br><span class="line">                                                                                                                                                                                                                        // 各种情况的判断。。。</span><br><span class="line">                                                                                                                                                                                                                            &#125;</span><br><span class="line">                                                                                                                                                                                                                            &#125;</span><br><span class="line">                                                                                                                                                                                                                            // 添加动画Annotation</span><br><span class="line">                                                                                                                                                                                                                            - (void)addAnimatedAnnotationWithName:(NSString *)name withAddress:(CLLocationCoordinate2D)coor &#123;</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                                                                                            </span><br><span class="line">                                                                                                                                                                                                                                    BMKPointAnnotation*animatedAnnotation = [[BMKPointAnnotation alloc]init];</span><br><span class="line">                                                                                                                                                                                                                                        animatedAnnotation.coordinate = coor;</span><br><span class="line">                                                                                                                                                                                                                                            animatedAnnotation.title = name;</span><br><span class="line">                                                                                                                                                                                                                                                [_mapView addAnnotation:animatedAnnotation];</span><br><span class="line">                                                                                                                                                                                                                                                &#125;</span><br></pre></td></tr></table></figure>                                                                                                                                                                                                                                            5.当地图区域发生改变时,会触发的方法有3个: &quot;正在改变&quot;、&quot;即将改变&quot;、&quot;改变完成&quot;。                                                                                                                                                                                                                                            ![屏幕快照_2016-06-16_下午3_54_33.png](http://upload-images.jianshu.io/upload_images/299599-62e02b40276d6d6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)                                                                                                                                                                                                                                            很容易就想到,我们需要使用的是&quot;改变完成&quot;的方法,在里面重新请求一次搜索:                                                                                                                                                                                                                                            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                                                                                                                                                                                                                                - (void)mapView:(BMKMapView *)mapView regionDidChangeAnimated:(BOOL)animated&#123;</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </span><br><span class="line">                                                                                                                                                                                                                                                        leftBottomPoint = [_mapView convertPoint:CGPointMake(0,_mapView.frame.size.height) toCoordinateFromView:mapView];  // //西南角（左下角） 屏幕坐标转地理经纬度</span><br><span class="line">                                                                                                                                                                                                                                                            rightBottomPoint = [_mapView convertPoint:CGPointMake(_mapView.frame.size.width,0) toCoordinateFromView:mapView];  //东北角（右上角）同上</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </span><br><span class="line">                                                                                                                                                                                                                                                                    [self beginSearch];</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </span><br><span class="line">                                                                                                                                                                                                                                                                        &#125;</span><br></pre></td></tr></table></figure>                                                                                                                                                                                                                                                                    **                                                                                                                                                                                                                                                                    总结: demo只实现了一个很基础的功能,后期还可以增加更加炫酷的功能,比如改变气泡的形状。如果你有更好的想法,欢迎和我交流!                                                                                                                                                                                                                                                                    **                                                                                                                                                                                                                                                                    demo地址:                                                                                                                                                                                                                                                                    []()https://github.com/xiaochenyi/BoundsSearchDemo</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#####实现百度地图显示范围内搜索关键词&lt;br&gt;效果图:&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/299599-b0d1d87d2a8c2cdc.gif?imageMogr2/auto-orie
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS圆球沿着椭圆轨迹做动画</title>
    <link href="http://yoursite.com/2018/02/06/iOS%E5%9C%86%E7%90%83%E6%B2%BF%E7%9D%80%E6%A4%AD%E5%9C%86%E8%BD%A8%E8%BF%B9%E5%81%9A%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/02/06/iOS圆球沿着椭圆轨迹做动画/</id>
    <published>2018-02-06T02:00:14.000Z</published>
    <updated>2018-02-06T02:00:30.275Z</updated>
    
    <content type="html"><![CDATA[<p>前言：最近公司项目有个需求，需要实现让一个view沿着椭圆轨迹做动画，效果实现后，就自己封装做了一个小demo，使用更方便。先看效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/299599-76e9f76b5bcbd85b.gif?imageMogr2/auto-orient/strip" alt="椭圆.gif"><br><em><br>效果图中的白色椭圆轨迹线其实是用贝塞尔曲线画出来的，为了清晰的看出来运动的轨迹。其实项目中是不显示轨迹线的，也就是小球是悬空运动的。若不需要删除掉即可。</em><br><strong><br>实现步骤：</strong></p><p>1.首先设定关键帧动画<strong>CAKeyframeAnimation</strong>的一些属性，比如运动时间和重复次数和calculationMode模式，我们选择<strong>kCAAnimationPaced</strong> 使得动画均匀进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    CAKeyframeAnimation *pathAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    pathAnimation.calculationMode = kCAAnimationPaced;</span><br><span class="line">    pathAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">    pathAnimation.removedOnCompletion = NO;</span><br><span class="line">    pathAnimation.duration = 5.0;</span><br><span class="line">    pathAnimation.repeatCount = 2;</span><br></pre></td></tr></table></figure></p><pre><code>2.设定好关键帧动画的path，即一个椭圆形的路径。需要使用**CGPathAddArc**，**CGPathAddArc**经常用于画正圆，比如下面就是一个正圆，各个参数的意义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     //160,200为圆心,100为半径 （startAngle，endAngle）为起始角度和结束角度，1为顺时针，0 为逆时针</span><br><span class="line">      CGPathAddArc(curvedPath, NULL, 160,200, 100, startAngle, endAngle, 0);</span><br></pre></td></tr></table></figure>  *  需要注意的是由于iOS中的坐标体系是和Quartz坐标体系中Y轴相反的，所以iOS UIView在做Quartz绘图时，Y轴已经做了Scale为-1的转换，因此造成CGPathAddArc函数最后一个是否是顺时针的参数结果正好是相反的，也就是说如果设置最后的参数为YES，根据参数定义应该是顺时针的，但实际绘图结果会是逆时针的！  *  我们需要画的是椭圆啊，别急，接下来稍作更改即可。正圆第二个参数默认为NULL，我们要改成椭圆，  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">      //短半轴和长半轴的比例</span><br><span class="line">          float radiuscale = 0.5;</span><br><span class="line">          //椭圆顶点的坐标值</span><br><span class="line">              CGFloat origin_x = self.frame.size.width/2;</span><br><span class="line">                  CGFloat origin_y = self.frame.size.height/2;</span><br><span class="line">                  //长半轴的长</span><br><span class="line">                      CGFloat radiusX = 100;</span><br><span class="line">                                                </span><br><span class="line">                              CGMutablePathRef curvedPath = CGPathCreateMutable();</span><br><span class="line">                                  CGAffineTransform t2 = CGAffineTransformConcat(CGAffineTransformConcat(</span><br><span class="line">                                                                                                             CGAffineTransformMakeTranslation(-origin_x, -origin_y),</span><br><span class="line">                                                                                                                                                                                        CGAffineTransformMakeScale(1, radiuscale)),</span><br><span class="line">                                                                                                                                                                                                                                           CGAffineTransformMakeTranslation(origin_x, origin_y));</span><br><span class="line">                                                                                                                                                                                                                                               CGPathAddArc(curvedPath, &amp;t2, origin_x, origin_y, radiusX,startAngle,endAngle, 1);</span><br><span class="line">                                                                                                                                                                                                                                                   pathAnimation.path = curvedPath;</span><br><span class="line">                                                                                                                                                                                                                                                       CGPathRelease(curvedPath);</span><br></pre></td></tr></table></figure>                                                                                                                                                                                                                                                   好了，至此，动画的轨迹和属性都写好了。添加到view上就ok了。                                                                                                                                                                                                                                                   3.贝塞尔画椭圆                                                                                                                                                                                                                                                   如果是整个椭圆的话，只需要设定好理想中的椭圆的外切圆即可。                                                                                                                                                                                                                                                   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                                                                                                                                                                                                                                           //整个椭圆</span><br><span class="line">                                                                                                                                                                                                                                                               CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">                                                                                                                                                                                                                                                                   CGContextSaveGState(context);</span><br><span class="line">                                                                                                                                                                                                                                                                       UIBezierPath *arc = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(origin_x-100, origin_y-50, 200, 100)];</span><br><span class="line">                                                                                                                                                                                                                                                                           [[UIColor whiteColor] setStroke];</span><br><span class="line">                                                                                                                                                                                                                                                                               [arc stroke];</span><br><span class="line">                                                                                                                                                                                                                                                                                   CGContextRestoreGState(context);</span><br></pre></td></tr></table></figure>                                                                                                                                                                                                                                                                               *****                                                                                                                                                                                                                                                                               **总结: 希望本文能对你有帮助。如果你有更好的想法,欢迎和我交流! **                                                                                                                                                                                                                                                                               demo地址:[https://github.com/xiaochenyi/CircleAnimateDemo](https://github.com/xiaochenyi/CircleAnimateDemo)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：最近公司项目有个需求，需要实现让一个view沿着椭圆轨迹做动画，效果实现后，就自己封装做了一个小demo，使用更方便。先看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/299599
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通俗易懂的讲解iOS中的证书知识</title>
    <link href="http://yoursite.com/2018/02/06/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2%E8%A7%A3iOS%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/02/06/通俗易懂的讲解iOS中的证书知识/</id>
    <published>2018-02-06T01:59:47.000Z</published>
    <updated>2018-02-06T01:59:52.819Z</updated>
    
    <content type="html"><![CDATA[<p>####前言：<br>iOS应用以流畅和安全著称，其中的安全性主要依靠的就是苹果开发中使用的一套证书流程。证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的，未经修改的。证书初次使用会感觉流程很复杂，其实对于流程理解了就会觉得简单了。</p><p>#####模拟流程<br>在讲解之前，我先用现实中的一件事做个比方，这样理解起来简单一点。比如：我要成立一个汽车厂。</p><ol><li>按照规定，我要先拿到经营许可证，然后拿着经营许可证去政府的车辆审批部门去申请制造汽车的资质证明书，而车辆审批部门会给我发俩个资质证明书，一个搞内部研发的资质证明书，一个可以投入市场的资质证明书，都是只有一年期限。</li><li>拿到资质证明书后，才可以开始汽车制造。首先我还必须要注册一个商标，这个商标要登记在车辆审批部门，防止别人伪造。</li><li>然后我拿着研发资质证明书，就可以进行研发了，经过科(加)学(班)规(加)范(点)的研发，车子终于成型，我想投入市场，但是为了安全，最好经过测试合格后才可以。</li><li>这时候我可以进行内部测试，审批部门每年会给我100个名额，我可以最多找100个人测试，这一百个人不必非要在授权的门店里买车，可以直接试车。需要注意的是，我在进行内部试车的时候，也分俩种情况，一种是在我自己规划的场地进行试车，另一种就是在外面的正常的公路上进行试车，但都是在没有检验合格证的情况下试车的。</li><li>试过之后，我就可以拿着投入市场的资质证明书给车检部门发出申请，然后他们要对我的车子进行检验审核，没有问题了，给我一个检验合格证，我就可以正式投入市场了。</li><li>投入市场后，来买车的人会看到我的资质证明书和我注册的商标以及检验合格证就可以确定这是正品，就可以放心来买了。</li><li>如果我想在车上安装导航系统，同样的也要申请俩个证书，一个开发导航资质证明书，一个发布导航资质证明书，同样是需要和商标绑在一起，一年期限。当然我也可以委托第三方厂家给我开发，只要我提供俩个资质证明书即可。</li></ol><p>#####实际开发流程<br>接下来，就回到iOS中的开发流程中来。</p><ol><li>首先我需要一个开发者账号，分为个人账号(Individual) 和 公司团队账号(Company/Organization)和企业账号(Enterprise)三种类型，个人和公司团队都是99美元一年，可以发布到AppStore上，每年可以有100个苹果的iOS设备测试。企业账号是299美元一年，但是不能发布到App Store，只能企业内部应用，苹果的iOS设备数量不限制。就好比我生产的车不能发布到市场上，只能在自己的地盘上试验，一旦上路就是黑车了，被检查到会被吊销营业资格。</li><li>有了账号，就可以申请经营许可证了，也就是通过Keychain（钥匙串）的证书助理从证书颁发机构请求证书。<br><img src="http://upload-images.jianshu.io/upload_images/299599-089b78b5280e2f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="455017-e84ef019ef4984b2.png"><br>结果keychain 将生成一个包含开发者身份信息和公钥的CSR（Certificate Signing Request）文件。私钥 private key始终保存在 Mac OS 的 Keychain Access 中，用于签名（CodeSign）本机对外发布的 App；公钥 public key 一般随证书散布出去，对 App 签名进行校验认证。用户必须妥善保存本地 Keychain 中的 private key，以防伪冒。<br><img src="http://upload-images.jianshu.io/upload_images/299599-cb79df190f0a3f62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20150114091003101.jpg"></li><li>使用CSR文件到开发者中心申请证书。首先要了解几个概念，Certificates(证书)，Identifiers(标识符)，Devices(设备)，Provisioning Profiles(描述文件)。页面如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/299599-233c2868686954a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160808_2.png">Certificates(证书)就是到车辆审批部门去申请的资质证明书，Identifiers(标识符)就是车的商标，Devices(设备)就是可以试车的那100个人，Provisioning Profiles(描述文件)就是包含了证书，标识符和设备的文件，也就是客户试车的时候的凭证。申请证书页面如图：<br><img src="http://upload-images.jianshu.io/upload_images/299599-a160111148c136ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="455017-7acbae0d954a0580.png">其中，Development就是开发证书，Production是发布证书，细分起来，发布证书分为AppStore发布证书和Ad Hoc发布证书，AppStore证书就是提交审核时用到的证书，也就类似于投入市场的资质证明书，Ad Hoc证书可以模拟生产环境，类似于在外面的正常的公路上试车那种类型。最后生成成功后download下来并双击导入钥匙串。<img src="http://upload-images.jianshu.io/upload_images/299599-7c70d3dcd09367bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20150114091440719.jpg">在多台机器上共享证书，在 Keychain Access|Certificates 中选中欲导出的 certificate 或其下 private key，右键 Export导出p12文件，其他 Mac 机器上双击 Certificates.p12（如有密码需输入密码）即可安装该共享证书。</li><li>接下来去申请一个App ID，也就是去申请一个汽车商标。在“ Identifiers”一栏下选择“App IDs”，可查看所有已申请的App IDs,点击右上“＋”，需要注意，App ID一般是反域名格式，如：com.company.test。在“App Services”栏下选择应用使用到的服务（如要使用推送功能，勾选“Push Notifications”）。</li><li>添加调试设备，也就是可以试车的人员，使用UDID来标识每一台设备都有唯一性，注意，一年只有100个名额，即使删除掉也算用去了一个名额。</li><li>添加描述文件（Provisioning Profile），描述文件和证书的环境相对应。描述文件就类似于售车时，给客户列出的一系列合法文件证明。<br><img src="http://upload-images.jianshu.io/upload_images/299599-c05c3e708d9f3cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160808_3.png"><blockquote><p>1.Provisioning Profile决定Xcode用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签名应用程序（Signing Product）,将在应用程序打包时嵌入到.ipa包里。<br>2.Provisioning Profile把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的Provisioning Profile文件就可以了。<br>3.Provisioning Profile也分为Development和Distribution两类，有效期同Certificate一样。Development版本的ProvisioningProfile用于开发调试，Distribution版本的ProvisioningProfile主要用于提交App Store审核，其不指定开发测试的Devices。<br>4.Xcode 将全部供应配置文件（包括用户手动下载安装的和 Xcode 自动创建的Provisioning Profile放在目录 [~/Library/MobileDevice/Provisioning Profiles] 下。</p></blockquote></li></ol><p>生成成功后的Provisioning Profile下载到本地，双击会自动安装到xcode中。<br>7.最后，如果需要开通推送功能，还需要再申请俩个推送证书，流程同开发证书一样。也可以使用第三方推送平台，但是得提供俩个环境的推送证书。<br><img src="http://upload-images.jianshu.io/upload_images/299599-99501c16357bb56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160808_5.png"></p><p>一切准备完毕，这时候就可以打包提交到AppStore进行审核了，类似于车检部门进行审核，审核通过后发到AppStore市场上，就类似于拿到了检验合格证了。</p><hr><p>iOS开发中的证书使用的流程就是这样了，希望本文能帮助到你更好的理解iOS开发。</p><p>参考：<br> <a href="http://blog.csdn.net/phunxm/article/details/42685597" target="_blank" rel="noopener">iOS Provisioning Profile(Certificate)与Code Signing详解</a><br> <a href="http://www.cnblogs.com/taintain1984/archive/2013/03/16/2963478.html" target="_blank" rel="noopener">苹果IOS开发者账号总结</a><br> <a href="http://www.jianshu.com/p/9d9e3699515e" target="_blank" rel="noopener">iOS开发证书与配置文件的使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####前言：&lt;br&gt;iOS应用以流畅和安全著称，其中的安全性主要依靠的就是苹果开发中使用的一套证书流程。证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的，未经修改的。证书初次使用会感觉流程很复杂，其实对于流程理解了就会觉得简单
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iTunes Connect: Simplified screenshot submission process.</title>
    <link href="http://yoursite.com/2018/02/06/iTunes-Connect-Simplified-screenshot-submission-process/"/>
    <id>http://yoursite.com/2018/02/06/iTunes-Connect-Simplified-screenshot-submission-process/</id>
    <published>2018-02-06T01:59:21.000Z</published>
    <updated>2018-02-06T01:59:28.220Z</updated>
    
    <content type="html"><![CDATA[<p>最近收到AppStore发来的一封邮件，标题为<strong><strong>iTunes Connect: Simplified screenshot submission process（简化截图提交过程）。 </strong></strong>内容如下：</p><blockquote><p>Now it’s easier than ever to deliver your screenshots and app preview using iTunes Connect. Just submit one set of screenshots and one optional app preview for the largest device size within a device family, and they will be used across all localizations and display sizes.<br>If your app’s UI or behavior changes based on device size, or if you would like to include localized screenshots, you can use the new Media Manager to add custom screenshots. <a href="https://developer.apple.com/videos/play/wwdc2016/305/?time=1700" target="_blank" rel="noopener">Learn more</a>.<br>If you have any questions or would like to get in touch, go to <a href="http://itunespartner.apple.com/apps?sc_cid=EMAP160808" target="_blank" rel="noopener">Resources and Help</a>.<br>Best regards,The App Store Team&gt;</p></blockquote><p>我们知道之前要提交时候至少要准备4套图，分别是3.5寸（640×960），4寸（640×1136），4.7寸（750×1334），5.5寸（1242×2208）。经过流程简化，我们只需要准备<strong><strong>最大尺寸</strong></strong>的截图，也就是5.5寸的即可。然后iTunes Connect会自动为我们生成其他尺寸的截图。登录到iTunes Connect也会发现界面有变化。如今只把5.5寸的展示在主要位置了，其他的都是折叠在一起,成为了可选项了。<br><img src="http://upload-images.jianshu.io/upload_images/299599-52143cd0fa33b9ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160821_2.png"><br>对于开发者来说，这也算是为我们提交的过程省了一部分精力吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近收到AppStore发来的一封邮件，标题为&lt;strong&gt;&lt;strong&gt;iTunes Connect: Simplified screenshot submission process（简化截图提交过程）。 &lt;/strong&gt;&lt;/strong&gt;内容如下：&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>APP升级到HTTPS流程详解</title>
    <link href="http://yoursite.com/2018/02/06/APP%E5%8D%87%E7%BA%A7%E5%88%B0HTTPS%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/02/06/APP升级到HTTPS流程详解/</id>
    <published>2018-02-06T01:59:00.000Z</published>
    <updated>2018-02-06T01:59:07.442Z</updated>
    
    <content type="html"><![CDATA[<p>#####1. 背景<br>2017年1月1日起，苹果App Store中的所有App都必须启用 App Transport Security(ATS)安全功能。App Transport Security(应用程序安全传输)，简称 ATS，是苹果在 iOS 9 中首次推出的一项隐私安全保护功能，启用ATS后，它会屏蔽明文HTTP资源加载，强制App通过HTTPS连接网络服务，通过传输加密保障用户数据安全。ATS在 iOS 9 中是默认开启的，但开发者仍然可以选择关闭 ATS，让自己的应用通过 HTTP 连接传输数据。但从2017年1月1日起，这招将行不通了，所有提交到 App Store 的App必须强制开启 ATS。</p><p>#####2. 影响<br>2.1 100%被拒的情况：</p><ul><li>使用自有网站的HTTP链接</li><li>使用自有网站低于TLS1.2标准的HTTPS链接。</li></ul><p>2.2以下几种情况是特例，不会被拒：</p><ul><li>App提供流媒体服务，媒体源已经对内容进行了加密，这时只要使用苹果的AV Foundation框架加载内容，就可以无视ATS；</li><li>App的内容如果有来自已知的第三方，可以暂时不用管，让技术设置一下ATS的开关，不过最好的做法是和第三方沟通下，敦促他们所有传输都使用TLS1.2加密。这一条适用于微信的公众号开发。</li><li>App的内容来自于不可知的第三方，比如说允许用户通过App访问任意网站,比如说浏览器app，可以忽视ATS。如果使用框架是WebKit，苹果建议切换到Safari，否则今后可能还会有麻烦事。</li></ul><p>#####3. HTTP和HTTPS的区别：<br>HTTP：当客户端发送请求，那么服务器会直接返回数据。</p><p><img src="http://upload-images.jianshu.io/upload_images/299599-df853a6f41a3fb1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>HTTPS：当客户端第一次发送请求的时候，服务器会返回一个包含公钥的受保护空间（也成为证书），当我们发送请求的时候，公钥会将请求加密再发送给服务器，服务器接到请求之后，用自带的私钥进行解密，如果正确再返回数据。这就是 HTTPS 的安全性所在。</p><p><img src="http://upload-images.jianshu.io/upload_images/299599-2e2163dc0aa7f77b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>更加详细的过程：<br>&#160; &#160; &#160; &#160;当浏览器（客户端）需要与某个安全站点建立连接时，先建立TCP连接（三次握手），然后发生 SSL会话握手。</p><ul><li>浏览器将通过网络发送请求安全会话的消息（通常请求以 https 而非 http 开头的 URL）。</li><li>服务器通过发送其证书（包括公钥）进行响应。</li><li>浏览器将检验服务器的证书是否有效，并检验该证书是否是由其证书位于浏览器的数据库中的（并且是可信的）CA 所签发的。它还将检验 CA 证书是否已过期。</li><li>如果证书有效，浏览器将生成一个==<strong>一次性的、唯一的</strong>==会话密钥，并使用服务器的公钥对该会话密钥进行加密。然后，浏览器将把加密的会话密钥发送给服务器，这样服务器和浏览器都有一份会话密钥。</li><li>服务器可以使用其专用密钥对消息进行解密，然后恢复会话密钥。</li></ul><p>####4.开始配置HTTPS</p><p>######4.1 准备工作</p><ul><li>有网站，有服务器，有域名；</li><li>申请到一个 SSL 证书；</li></ul><p>######4.2 生成证书的申请文件：<br>1.先通过 openssl 工具创建一个私钥文件mydomain.key。</p><pre><code>sudo openssl genrsa -des3 -out mydomain.key 1024&gt;不同的证书是可能有加密位数不同的，这里用的是 1024，但有可能是 2048；这个 openssl 工具在 windows 和 linux 上面都可以用。2.然后我们通过下面的命令生成申请文件 (mydomain.csr)。sudo openssl req -new -key mydomain.key -out mydomain.csr这个 csr 文件在向证书颁发机构申请证书的时候需要提交，需要根据上一步的私钥才能产生，然后会需要输入下面一系列的信息：![Paste_Image.png](http://upload-images.jianshu.io/upload_images/299599-94d5588f5ab72c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)最终生成好 csr 申请文件，就可以开始申请证书了。######4.3 申请证书按验证的类别分：*  域名认证（Domain Validation）：认证你的域名所有权和网站，申请验证简单，几分钟即可。*  组织机构认证（Organization Validation）：认证的域名和公司信息需要提交公司资料认证。*  扩展认证（Extended Validation，简称EV）：这种证书会在浏览器中出现“很明显”的绿色地址栏，给用户的可信度最高。有安全评估保证。&gt; 个人或小站点可用一类或二类，企业一般用二类认证，少数企业会用到EV认证。看了看网上SSL证书的价格，便宜的一般都是10美元左右一个子域名/每年，按不同类别、不同品牌等价格在几十美元到几百美元一年。比如能显示绿色地址栏的EV证书和通配符证书贵一些。国内自己的或代理的，比国外贵不少，动辄几千元。其实就是由可信源认证了一下，类似于办证，用起来没什么差别，并非越贵越好。国外常见的SSL提供商有：Thawte，Go Daddy，VeriSign，RapidSSL，GeoTrust（QuickSSL），StartSSL。StartSSL、Go Daddy的比较便宜，GeoTrust的价格适中，Thawte和VeriSign的价格较贵。其中StartSSL的价格是119.8美元/年https://www.startssl.com/![Paste_Image.png](http://upload-images.jianshu.io/upload_images/299599-e84b55981b438dd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)Go Daddy的价格是669人民币/年https://sg.godaddy.com/zh/web-security/ssl-certificate/ov-ssl-certificate![Paste_Image.png](http://upload-images.jianshu.io/upload_images/299599-baf58a975d76a179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)最终我们会得到一个.crt证书文件。凭着手上已经注册好的 mydomain.crt 证书和 mydomain.key 私钥文件，就可以在我们的 http 服务上面配置 SSL 了。####5. **Nginx ****配置启用**** SSL**5.1 在原有的虚拟主机 server 段配置上修改端口为 443，然后加入如下三行 SSL 配置：server {    listen 443;        ssl on;            ssl_certificate /var/ssl/mydomain.crt;                ssl_certificate_key /var/ssl/mydomain.key;                }                5.2新增一个 server 段侦听同样域名上的 80 端口，直接 301 跳转到 https 协议上的地址：                server {                    listen 80;                        server_name www.mydomain.com mydomain.com;                            rewrite ^/(.*)$ https://$host/$1 permanent;                            }                            5.3然后重启一下 Nginx，这时候会要求输入私钥的密码，日后每次重启 Nginx都需要这一步。                            至此就配置完毕了。                            参考文档：                            [SSL证书与Https应用部署小结](http://han.guokai.blog.163.com/blog/static/136718271201211631456811/)                            [HTTPS(SSL) 升级实践手札](https://www.huangwenchao.com.cn/2015/07/https-update-log.html)                            [iOS应用网络安全之HTTPS](http://www.jianshu.com/p/c6a903da8346)                            [iOS - HTTPS](http://www.jianshu.com/p/4b5d2d47833d)                            [StartSSL免费SSL证书成功申请](https://www.freehao123.com/startssl-ssl/)                            [App上架重磅通知：App Store安全新规17年1月生效](http://mp.weixin.qq.com/s?__biz=MzA3NzM0NzkxMQ==&amp;mid=2655358269&amp;idx=1&amp;sn=1d532a948b0e3315c09365a61e780003&amp;chksm=84e24015b395c903e0da3aef5fabbc1063beb5158eba3a61fdd4529fd6f7e02c4211f89cfa63&amp;mpshare=1&amp;scene=1&amp;srcid=1020ss0nxsJ3JqjOHdw8KJrB#rd)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#####1. 背景&lt;br&gt;2017年1月1日起，苹果App Store中的所有App都必须启用 App Transport Security(ATS)安全功能。App Transport Security(应用程序安全传输)，简称 ATS，是苹果在 iOS 9 中首次推出
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 多个PDF的加载显示</title>
    <link href="http://yoursite.com/2018/02/06/iOS-%E5%A4%9A%E4%B8%AAPDF%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/02/06/iOS-多个PDF的加载显示/</id>
    <published>2018-02-06T01:58:27.000Z</published>
    <updated>2018-02-06T01:58:42.538Z</updated>
    
    <content type="html"><![CDATA[<p>####前言：<br>加载一个pdf本地文件很简单，使用UIWebView或者CGContextDrawPDFPage都可以实现，但是要想多个PDF文件在一个ViewController上加载而又不失流畅该怎么办呢？本文就来实现这一效果。</p><p>#####先看效果图:</p><p><img src="http://upload-images.jianshu.io/upload_images/299599-d09ddbae0a9f9c38.gif?imageMogr2/auto-orient/strip" alt="2016-12-06 21_37_26.gif"></p><hr><p>####实现思路：</p><ol><li><p>拿到每个PDF的页数，得到所有的PDF文件的总和 <code>totalNum</code> ，作为下标的显示数据。</p></li><li><p>每次翻页，记住当前的页数在全部页数的位置。当翻到第一个PDF文件的最后一页时，取出第二个PDF文件的第一页作为下一页展示，做无痕连接。</p></li><li><p>之后的展示同步骤2，尤其要注意：下标是在累加的基础上的结果。</p></li></ol><hr><p>####技术要点：</p><ol><li>得到PDF文件的页数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *filename = @&quot;1.pdf&quot;;</span><br><span class="line">        CFURLRef pdfURL = CFBundleCopyResourceURL(CFBundleGetMainBundle(), (__bridge CFStringRef)filename, NULL, NULL);</span><br><span class="line">        CGPDFDocumentRef pdfDocument = CGPDFDocumentCreateWithURL((CFURLRef)pdfURL);</span><br><span class="line">        CFRelease(pdfURL);</span><br><span class="line">        NSInteger indexSum = CGPDFDocumentGetNumberOfPages(pdfDocument);</span><br></pre></td></tr></table></figure><pre><code>2.根据当前显示页数，判断出当前显示的是第几个文件，然后取出对应的后续文件补充显示，我使用的是取下限以及上限的方法。例如：文件一和文件二都有3页，如果当前显示为4，说明到达了第二个文件的下限了，再往前翻页就得取出第一个文件的最后一页来显示了。如果显示到第6页的话，说明到达第二个文件的上限了。接下来如果往后翻的话就要取出第三个文件的第一页来补充了。3.绘制PDF内容需要使用`CGContextDrawPDFPage`,避免页数太多的时候卡顿。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">            CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">                //调整坐标系</span><br><span class="line">                    CGContextTranslateCTM(context, 0.0, self.bounds.size.height);//先垂直下移height高度</span><br><span class="line">                        CGContextScaleCTM(context, 1.0, -1.0);//再垂直向上翻转</span><br><span class="line">                            //绘制pdf内容</span><br><span class="line">                                CGPDFPageRef pageRef = CGPDFDocumentGetPage(pdfDocument, page);</span><br><span class="line">                                    CGContextSaveGState(context);</span><br><span class="line">                                        CGAffineTransform pdfTransform = CGPDFPageGetDrawingTransform(pageRef, kCGPDFCropBox, self.bounds, 0, true);</span><br><span class="line">                                            CGContextConcatCTM(context, pdfTransform);</span><br><span class="line">                                                CGContextDrawPDFPage(context, pageRef);</span><br><span class="line">                                                    CGContextRestoreGState(context);</span><br></pre></td></tr></table></figure>                                            github项目地址： [https://github.com/xiaochenyi/PDFtest](https://github.com/xiaochenyi/PDFtest)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####前言：&lt;br&gt;加载一个pdf本地文件很简单，使用UIWebView或者CGContextDrawPDFPage都可以实现，但是要想多个PDF文件在一个ViewController上加载而又不失流畅该怎么办呢？本文就来实现这一效果。&lt;/p&gt;
&lt;p&gt;#####先看效果图
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>马拉松新手攻略</title>
    <link href="http://yoursite.com/2018/02/06/%E9%A9%AC%E6%8B%89%E6%9D%BE%E6%96%B0%E6%89%8B%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2018/02/06/马拉松新手攻略/</id>
    <published>2018-02-06T01:57:40.000Z</published>
    <updated>2018-02-06T01:57:50.588Z</updated>
    
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;马拉松是一场体力消耗巨大的运动，需要讲究方式方法。对于体力超常的人来说没什么，但是如果是普通人的话，就得老老实实的进行一个科学的行程规划了。这之间包含了配速，补给和休息的有序安排。</p><p>&#160; &#160; &#160; &#160; 首先，在赛前的准备来说，赛前一天应大量饮水，以3升为宜，排尿和清水颜色时就说明可以了。保证好的睡眠和早餐，以易消化，多能量为好，可选择馒头，饼，米粥之类。可加咸菜之类的补充盐分。尽量备齐能量胶，盐丸，尽量每五公里补充一次能量和水。如果自带饮水的话，也能节省一部分停下来补给的时间。</p><p>&#160; &#160; &#160; &#160;赛前一定要准备热身，还有尽量往起点挤有助于节省时间。跑步中，对于前半程来说，因为精神处于亢奋期，而且体力基础好，所以应匀速跑，为后半程节省体力。尽量减少停下来休息的次数，因为每次休息都会有更多的疲惫感汹涌的涌上来。累的时候就减速一会儿，但是不能停下来，更不要蹲下。腿部感觉到酸是正常的。途中想上厕所也是正常的，因为膀胱内的尿液浓度很高，刺激性大，其实没有多少尿量。所以全程不上厕所也没关系。<br>&#160; &#160; &#160; &#160;<br>从后半程来说，就是在拼耐力的时期了，原则来说，在30公里之前都不要用走的方式，因为撞墙期一般在30公里，要把时间都留给撞墙期的调整，如果能坚持到30公里，这时候可以适当的走走跑跑了，要坚持一个想法，就是浑身疼痛是正常的，嘴干舌燥是正常的，但是这还没到极限，极限的状态是心跳过快，恶心难受，所以只要没到极限就要坚持。最好能走500米，小跑500米，撞墙期大概会在一小时左右，过去这个坎后，应该还有5公里，这后面的5公里，身体已经适应下来了，可以进行最后阶段的冲刺了。</p><p>&#160; &#160; &#160; &#160;结束后不要忘了拉伸，一小时内补充高能量的食物。并做好保暖。</p><hr><p>一些小技巧：</p><ul><li>每跑一公里就提醒一下剩余的公里数，这样有越来越少的感觉。</li><li>有冰块和喷雾的时候可以缓解下膝盖的酸痛感。</li><li>不要洗脸，会把脸上的盐洗到嘴里，增加口渴感。</li><li>走路不是普通的走，而是大步的走路。</li><li>算好关门时间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;马拉松是一场体力消耗巨大的运动，需要讲究方式方法。对于体力超常的人来说没什么，但是如果是普通人的话，就得老老实实的进行一个科学的行程规划了。这之间包含了配速，补给和休息的有序安排。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在画布上涂鸦并截取画笔轨迹保存到相册</title>
    <link href="http://yoursite.com/2018/02/06/%E5%9C%A8%E7%94%BB%E5%B8%83%E4%B8%8A%E6%B6%82%E9%B8%A6%E5%B9%B6%E6%88%AA%E5%8F%96%E7%94%BB%E7%AC%94%E8%BD%A8%E8%BF%B9%E4%BF%9D%E5%AD%98%E5%88%B0%E7%9B%B8%E5%86%8C/"/>
    <id>http://yoursite.com/2018/02/06/在画布上涂鸦并截取画笔轨迹保存到相册/</id>
    <published>2018-02-06T01:56:47.000Z</published>
    <updated>2018-02-06T01:57:03.865Z</updated>
    
    <content type="html"><![CDATA[<p>有时候如果想和iPad pro的画板一样涂鸦然后保存后发给朋友，这时候在iPhone上怎么实现呢，下面我就来一步一步的实现这个功能。</p><p>按照惯例，先上效果图：<br><img src="http://upload-images.jianshu.io/upload_images/299599-3ad2d38f99bb6dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-09-19 下午2.53.05.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/299599-c326947549ee0ec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-09-19 下午2.53.14.png">  <br><br></p><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>每当画笔在画布上有所动作，都会将画布上新的轨迹保存在一个全局的可变数组里，展示的时候进行渲染，如果选择了撤销，就清空数组，重新渲染页面。所以不可避免的要用到CGContextRef 上下文来实现这一功能。</p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">//创建笔画的数组</span><br><span class="line">NSMutableArray *arry=[[NSMutableArray alloc]init];</span><br><span class="line">//将颜色添加到笔画数组中</span><br><span class="line">[arry addObject:color];</span><br><span class="line">[arry addObject:[NSNumber numberWithInt:font]];</span><br><span class="line">//得到触摸对象</span><br><span class="line">UITouch *touch=[touches anyObject];</span><br><span class="line">//将触摸对象装化为触摸点</span><br><span class="line">CGPoint point=[touch locationInView:self];</span><br><span class="line">//将point转换为对象类型</span><br><span class="line">NSValue *pointValue=[NSValue valueWithCGPoint:point];</span><br><span class="line">//将得到的起点添加到数组里面</span><br><span class="line">[arry addObject:pointValue];</span><br><span class="line">//将笔画数组放在子数组里面</span><br><span class="line">[ziArry addObject:arry];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">//循环一个字有多少笔画</span><br><span class="line">for (int i=0; i&lt;[ziArry count]; i++) &#123;</span><br><span class="line">NSMutableArray *bihua=[ziArry objectAtIndex:i];</span><br><span class="line">//设置绘画属性、</span><br><span class="line">//拿到画笔</span><br><span class="line">contex=UIGraphicsGetCurrentContext();</span><br><span class="line">//设置画笔的粗细</span><br><span class="line">CGContextSetLineWidth(contex, [bihua[1] intValue]);</span><br><span class="line">//设置画笔的颜色</span><br><span class="line">CGContextSetStrokeColorWithColor(contex, [bihua[0] CGColor]);</span><br><span class="line">//内层循环是用来处理每个笔画有多少个点</span><br><span class="line">for (int j=2; j&lt;[bihua count]-2; j++) &#123;</span><br><span class="line">//将点连成线</span><br><span class="line">//将对象类型的点从数组中取出来</span><br><span class="line">NSValue *pointValue=[bihua objectAtIndex:j];</span><br><span class="line">//将对象类型转换成point</span><br><span class="line">CGPoint first=[pointValue CGPointValue];</span><br><span class="line">//两点画线，取到后面的一个点</span><br><span class="line">CGPoint second=[[bihua objectAtIndex:j+1] CGPointValue];</span><br><span class="line">//设定线的起点和终点</span><br><span class="line">CGContextMoveToPoint(contex, first.x, first.y);</span><br><span class="line">//用点连接成线</span><br><span class="line">CGContextAddLineToPoint(contex, second.x, second.y);</span><br><span class="line">//提交画笔</span><br><span class="line">CGContextStrokePath(contex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想像微信表情一样发送的都是有透明度的图片的话，就必须要使用png格式的图片了，所以一般的截图方法就不能用了，因为那样会把底部背景也带上。我们使用另一种办法UIGraphicsBeginImageContextWithOptions截图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//1、获得图片的画布（上下文）</span><br><span class="line">//2、画布的上下文</span><br><span class="line">//3、设置截图的参数 截图</span><br><span class="line">//4、关闭图片的上下文</span><br><span class="line">//5、保存</span><br><span class="line">UIGraphicsBeginImageContext(self.frame.size);</span><br><span class="line">/**</span><br><span class="line">*  size ：图片尺寸</span><br><span class="line">* opaque: 是否不透明</span><br><span class="line">* scale :比例</span><br><span class="line">*/</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 1);</span><br><span class="line">//    [self addRound];</span><br><span class="line">CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">[self.layer renderInContext:ctx];</span><br><span class="line"></span><br><span class="line">//开始截图</span><br><span class="line">UIImage *image =   UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">//关闭截图上下文</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">//UIImage转换成png</span><br><span class="line">NSData* imageData =  UIImagePNGRepresentation(image);</span><br><span class="line">UIImage* pngImage = [UIImage imageWithData:imageData];</span><br></pre></td></tr></table></figure></p><p>github项目地址： <a href="https://github.com/hfq-wangqiuyu/PrintView" target="_blank" rel="noopener">https://github.com/hfq-wangqiuyu/PrintView</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候如果想和iPad pro的画板一样涂鸦然后保存后发给朋友，这时候在iPhone上怎么实现呢，下面我就来一步一步的实现这个功能。&lt;/p&gt;
&lt;p&gt;按照惯例，先上效果图：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift 使用Runtime自定义UIDatePicker</title>
    <link href="http://yoursite.com/2018/02/05/Swift-%E4%BD%BF%E7%94%A8Runtime%E8%87%AA%E5%AE%9A%E4%B9%89UIDatePicker/"/>
    <id>http://yoursite.com/2018/02/05/Swift-使用Runtime自定义UIDatePicker/</id>
    <published>2018-02-05T14:36:06.000Z</published>
    <updated>2018-02-05T14:36:19.367Z</updated>
    
    <content type="html"><![CDATA[<p>####前言：<br>UIDatePicker是比较常用的一个控件了，但是苹果却只提供极少的属性可以让我们使用，所以实际运用中难免要自定义。这里我提供俩种方法来改变UIDatePicker的显示字体颜色。显示效果如下：</p><hr><p><img src="http://upload-images.jianshu.io/upload_images/299599-710738310ceb21d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-12-07 下午11.06.45.png"></p><hr><p>######首先是第一种方法：runtime<br>我们知道，runtime可以遍历一个对象的所有属性，虽然苹果没有公开UIDatePicker的字体颜色，但是我们可以遍历查找对应的属性名，并加以修改就可以实现了。<br>关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//MARK:runtime遍历所有属性名，并加以修改</span><br><span class="line">func setDateTextColor(picker:UIDatePicker)&#123;</span><br><span class="line">var count:UInt32 = 0</span><br><span class="line">let propertys = class_copyPropertyList(UIDatePicker.self, &amp;count)</span><br><span class="line">for index in 0..&lt;count &#123;</span><br><span class="line">let i = Int(index)</span><br><span class="line">let property = propertys![i]</span><br><span class="line">let propertyName = property_getName(property)</span><br><span class="line"></span><br><span class="line">let strName = String.init(cString: propertyName, encoding: String.Encoding.utf8)</span><br><span class="line">if strName == &quot;textColor&quot;&#123;</span><br><span class="line">picker.setValue(UIColor.red, forKey: strName!)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>#####第二种方法：自定义UIPickerView<br>相比而言，UIPickerView可以使用比较多的属性进行操作，所以我们不妨曲线救国，使用UIPickerView来实现UIDatePicker的功能。此方法比较繁琐，但是可以高度自定义。</p><p>具体思路：</p><ul><li><p>准备3个数组存放年，月，日的数据，其中日的数组要根据相应的年和月来处理不同情况，月份还有闰年都会影响到，所以这一步需要小心计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/// 计算每个月的天数</span><br><span class="line">fileprivate func daysCount(year:Int,month:Int) -&gt; Int&#123;</span><br><span class="line">let isrunNian = year%4 == 0 ? (year%100 == 0 ? (year%400 == 0 ? true:false):true):false</span><br><span class="line">if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12&#123;</span><br><span class="line">self.setDayArr(num: 31)</span><br><span class="line">return 31</span><br><span class="line">&#125;else if month == 4 || month == 6 || month == 9 || month == 11&#123;</span><br><span class="line">self.setDayArr(num: 30)</span><br><span class="line">return 30</span><br><span class="line">&#125;else if month == 2&#123;</span><br><span class="line">if isrunNian&#123;</span><br><span class="line">self.setDayArr(num: 29)</span><br><span class="line">return 29</span><br><span class="line">&#125;else&#123;</span><br><span class="line">self.setDayArr(num: 28)</span><br><span class="line">return 28</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据源准备好后，就开始实现UIPickerView的代理方法吧，切换年或者月份的时候会影响到日这一列的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) &#123;</span><br><span class="line">if component == 0 &#123;</span><br><span class="line">yearIndex = row</span><br><span class="line">&#125;</span><br><span class="line">if component == 1 &#123;</span><br><span class="line">monthIndex = row</span><br><span class="line">&#125;</span><br><span class="line">if component == 2 &#123;</span><br><span class="line">dayIndex = row</span><br><span class="line">&#125;</span><br><span class="line">if component == 0 || component == 1&#123;</span><br><span class="line">let selctYear = (yearArray![yearIndex!] as! NSString).intValue</span><br><span class="line">let selctMonth = (monthArray![monthIndex!] as! NSString).intValue</span><br><span class="line">let _ = self.daysCount(year: Int(selctYear) , month: Int(selctMonth))</span><br><span class="line"></span><br><span class="line">if (dayArray?.count)!-1 &lt; dayIndex! &#123;</span><br><span class="line">dayIndex = (dayArray?.count)!-1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pickerView.reloadAllComponents()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后别忘了我们的初衷，就是自定义显示字体颜色。重写<br><strong>pickerView viewForRow: forComponent:(NSInteger)component reusingView:</strong>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView &#123;</span><br><span class="line">let headLabel = UILabel.init()</span><br><span class="line">headLabel.textColor  = UIColor.red</span><br><span class="line">headLabel.textAlignment = NSTextAlignment.center</span><br><span class="line">if component == 0 &#123;</span><br><span class="line">headLabel.text = yearArray?[row] as? String</span><br><span class="line">&#125;</span><br><span class="line">if component == 1 &#123;</span><br><span class="line">headLabel.text = monthArray?[row] as? String</span><br><span class="line">&#125;</span><br><span class="line">if component == 2 &#123;</span><br><span class="line">headLabel.text = dayArray?[row] as? String</span><br><span class="line">&#125;</span><br><span class="line">return headLabel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就大功告成了。</p><hr><p>######结语：Swift和OC在使用上还是有不少区别的，我刚用的时候也踩了不少坑，不过对于数据类型的使用确实比较严谨，感觉程序应该会更健壮了。</p><p>github项目地址： <a href="https://github.com/wang-qiuyu/CustomDatePicker" target="_blank" rel="noopener">https://github.com/wang-qiuyu/CustomDatePicker</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####前言：&lt;br&gt;UIDatePicker是比较常用的一个控件了，但是苹果却只提供极少的属性可以让我们使用，所以实际运用中难免要自定义。这里我提供俩种方法来改变UIDatePicker的显示字体颜色。显示效果如下：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http:
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/02/05/hello-world/"/>
    <id>http://yoursite.com/2018/02/05/hello-world/</id>
    <published>2018-02-05T08:50:21.664Z</published>
    <updated>2018-02-05T08:50:21.664Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
